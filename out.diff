diff --git a/process-signal-env.odin b/process-signal-env.odin
index 94a5897..b51c7fb 100644
--- a/process-signal-env.odin
+++ b/process-signal-env.odin
@@ -6,11 +6,17 @@ import "core:fmt"
 import "core:time"
 import "core:os/os2"
 
+_gen_odin: [64]u8
+
 _run_background :: proc(program: string, env: []string = {}, loc := #caller_location) -> os2.Process {
-	f := create_write("generated.odin", program)
+	@static i := 0
+	fmt.bprintf(_gen_odin[:], "generated%d.odin", i)
+	i += 1
+
+	f := create_write(string(_gen_odin[:]), program)
 	assume_ok(os2.close(f), loc)
 
-	args: [4]string = {"run", "generated.odin", "-file", "-debug"}
+	args: [4]string = {"run", string(_gen_odin[:]), "-file", "-out:generated"}
 
 	attr: ^os2.Process_Attributes
 	if len(env) > 0 {
@@ -37,7 +43,7 @@ _reap :: proc(process: ^os2.Process, loc := #caller_location) -> int {
 	state, err := os2.process_wait(process)
 	assume_ok(err, loc)
 	assert(bool(process.is_done), "", loc)
-	assume_ok(os2.remove("generated.odin"), loc)
+	assume_ok(os2.remove(string(_gen_odin[:])), loc)
 	return state.exit_code
 }
 
@@ -108,11 +114,12 @@ process_env :: proc() {
 	package auto
 	import "core:os/os2"
 	main :: proc() {
+		res := 0
 		env := os2.environ()
-		assert(len(env) > 0)
+		if len(env) <= 0 { os2.exit(1) }
 		os2.clear_env()
 		env = os2.environ()
-		assert(len(env) == 0)
+		if len(env) != 0 { os2.exit(2) }
 	}
 	`
 	assert(_run(program) == 0)
@@ -125,12 +132,11 @@ process_env :: proc() {
 	import "core:os/os2"
 	main :: proc() {
 		val, found := os2.lookup_env("var_to_read_in_child")
-		assert(found && val == "child")
+		if !found { os2.exit(1) }
+		if val != "child" { os2.exit(2) }assert(found && val == "child")
 	}
 	`
 	assert(_run(program) == 0)
-
-	fmt.print("Expecting Error: ")
 	assert(_run(program, org_env) != 0)
 }
 
@@ -163,10 +169,14 @@ process_signals :: proc() {
 	p = _run_background(program)
 	assume_ok(os2.process_kill(&p))
 
+	time.sleep(500 * time.Millisecond)
+
 	state, err := os2.process_wait(&p, time.Duration(0))
 	assume_ok(err)
 	assert(bool(p.is_done))
 	assert(state.exit_code != 0)
+	assume_ok(os2.remove("generated"))
+	assume_ok(os2.remove(string(_gen_odin[:])))
 }
 
 process_pipes :: proc() {
